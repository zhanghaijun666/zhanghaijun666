import{_ as u,C as r,c as t,o as n,j as a,G as l,a5 as i,a as c}from"./chunks/framework.CBqkjkG0.js";const g=JSON.parse('{"title":"Java队列","description":"","frontmatter":{},"headers":[],"relativePath":"31_后端Java/11_Java基础/Java--queue.md","filePath":"31_后端Java/11_Java基础/Java--queue.md","lastUpdated":1739184584000}'),d={name:"31_后端Java/11_Java基础/Java--queue.md"};function k(s,e,q,h,b,p){const o=r("ArticleMetadata");return n(),t("div",null,[e[0]||(e[0]=a("h1",{id:"java队列",tabindex:"-1"},[c("Java队列 "),a("a",{class:"header-anchor",href:"#java队列","aria-label":'Permalink to "Java队列"'},"​")],-1)),l(o),e[1]||(e[1]=i('<h2 id="blockingqueue的实现子类" tabindex="-1">BlockingQueue的实现子类 <a class="header-anchor" href="#blockingqueue的实现子类" aria-label="Permalink to &quot;BlockingQueue的实现子类&quot;">​</a></h2><h3 id="arrayblockingqueue" tabindex="-1">ArrayBlockingQueue <a class="header-anchor" href="#arrayblockingqueue" aria-label="Permalink to &quot;ArrayBlockingQueue&quot;">​</a></h3><blockquote><p>基于数组的有界阻塞队列，大小在初始化时固定。生产者和消费者通过相同的锁进行同步。</p></blockquote><h3 id="linkedblockingqueue" tabindex="-1">LinkedBlockingQueue <a class="header-anchor" href="#linkedblockingqueue" aria-label="Permalink to &quot;LinkedBlockingQueue&quot;">​</a></h3><blockquote><p>基于链表的阻塞队列，可以是有界的或无界的（如果没有指定容量，默认为 Integer.MAX_VALUE）。生产者和消费者使用不同的锁，提供了更高的并发性。</p></blockquote><h3 id="priorityblockingqueue" tabindex="-1">PriorityBlockingQueue <a class="header-anchor" href="#priorityblockingqueue" aria-label="Permalink to &quot;PriorityBlockingQueue&quot;">​</a></h3><blockquote><p>基于优先级排序的无界阻塞队列，元素会根据其自然顺序或 Comparator 排序放置。没有大小限制，因此不会阻塞插入操作。</p></blockquote><h3 id="synchronousqueue" tabindex="-1">SynchronousQueue <a class="header-anchor" href="#synchronousqueue" aria-label="Permalink to &quot;SynchronousQueue&quot;">​</a></h3><blockquote><p>没有容量的特殊队列，每一个插入操作必须等待相应的移除操作。常用于在两个线程之间直接传递数据。</p></blockquote><h3 id="delayqueue" tabindex="-1">DelayQueue <a class="header-anchor" href="#delayqueue" aria-label="Permalink to &quot;DelayQueue&quot;">​</a></h3><blockquote><p>采用优先队列的无界阻塞队列，元素只有在其延迟时间到期后才能被获取。常用于调度任务等场景。</p></blockquote><h3 id="linkedtransferqueue" tabindex="-1">LinkedTransferQueue <a class="header-anchor" href="#linkedtransferqueue" aria-label="Permalink to &quot;LinkedTransferQueue&quot;">​</a></h3><blockquote><p>一个加强版的 LinkedBlockingQueue，提供 transfer 方法，生产者可以等待消费者接收数据。</p></blockquote><h3 id="linkedblockingdeque" tabindex="-1">LinkedBlockingDeque <a class="header-anchor" href="#linkedblockingdeque" aria-label="Permalink to &quot;LinkedBlockingDeque&quot;">​</a></h3><blockquote><p>双端阻塞队列，允许从两端插入和移除元素，可以用作栈或队列使用。</p></blockquote>',15))])}const f=u(d,[["render",k]]);export{g as __pageData,f as default};
